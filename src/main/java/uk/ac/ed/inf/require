1
Functional Requirements
Order Processing: Validating and assigning delivery orders.
OrderProcess.java
Drone Pathfinding: A* algorithm to compute the optimal delivery path.
Astar.java
Flight Path Execution: Ensuring drones avoid no-fly zones while efficiently delivering orders.
GetFlightPath.java

2
Performance Requirements
Route Calculation Time: Must within 1 second for efficiency.
Concurrent Order Processing: System should handle at least 50 concurrent orders without performance degradation.
Delivery Success Rate: 98%+ success rate under normal conditions.

Robustness and Security Requirements
Drone Resilience: The system should handle simultaneous drone failures without service disruption.
Weather Adaptation: Routes should be adaptable to high winds and adverse weather conditions.
Data Security: Communication between drones, servers, and customers must be encrypted to prevent tampering.

Testing Strategy Alignment
The testing approach included unit testing, integration testing, and stress testing. However, security vulnerabilities (e.g., unauthorized drone access and communication encryption validation) need further attention.


2. Design and Implement Test Plans (20%)
2.1 Test Plan Structure
A structured test plan was implemented, covering:

Functional Tests: Order validation, path calculation, and drone movement.
Performance Tests: Ensuring <1s route computation and 50+ concurrent orders.
Stress Tests: Simulating extreme order loads.
Edge Case Handling: Invalid orders, unreachable delivery locations, and multiple drone failures.
2.2 Instrumentation and Monitoring
JaCoCo was used to monitor test coverage.
JUnit was applied for automated test execution.
Performance timers ensured response times met requirements.
2.3 Gaps in Testing
While the test plan effectively covered most functional aspects, it lacked rigorous testing for rare extreme failures (e.g., simultaneous drone breakdowns, GPS failures, and high-wind conditions).

Score: 17/20 – Well-structured test plan but lacking extreme failure simulations.

3. Apply Testing Techniques (20%)
3.1 Functional Testing
Validated that:

Orders are properly assigned to drones.
The pathfinding algorithm computes optimal routes.
Invalid inputs (e.g., wrong addresses) trigger correct error responses.
3.2 Performance and Stress Testing
Simulated 20+ concurrent orders ✅ Passed
Simulated 50+ concurrent orders ✅ Passed
Route calculation time < 1 second ✅ Passed
3.3 Boundary and Edge Case Testing
Drone near a no-fly zone? ✅ Correct re-routing.
Customer location outside coverage? ✅ Correct rejection.
Incorrect GPS data? ❌ Not sufficiently tested.
3.4 White-box and Black-box Testing
Black-box testing: Verified system behavior with different inputs.
White-box testing: Checked uncovered paths in A pathfinding logic*.
3.5 Weaknesses in Testing
Rare failure conditions (multiple drones failing at once) were not fully tested.
Score: 16/20 – Effective testing, but some critical failure scenarios remain untested.

4. Evaluate Limitations (20%)
4.1 Testing Gaps Identified
Hardware Testing: No real drone hardware-in-the-loop testing was conducted.
Environmental Conditions: High winds and GPS errors were not simulated.
Security Testing: No explicit penetration testing was performed.
4.2 Improvement Plan
Simulate extreme conditions (e.g., simultaneous drone failures, high winds).
Expand stress testing to include 100+ concurrent orders.
Implement security testing to validate encryption and prevent drone hijacking.
Introduce hardware-in-the-loop testing to validate real-world drone behavior.
Score: 17/20 – Good identification of gaps, but hardware testing needs integration.

5. Reviews, Inspections, and Automation (20%)
5.1 Code Reviews
Reviewed critical modules (pathfinding, order assignment, error handling).
Identified redundant computations in pathfinding and optimized them.
Improved error handling (added handling for missing orders).
5.2 CI Pipeline Implementation
Implemented GitHub Actions-based CI pipeline:

Code Compilation mvn compile
Static Analysis: Checkstyle and SpotBugs
Unit Testing: JUnit
Code Coverage Report: JaCoCo (min 85%)
Deployment Simulation: java -jar PizzaDronz-1.0-SNAPSHOT.jar
5.3 Automation Improvements
Increased test automation using JUnit and JaCoCo.
Enabled automated coverage checks (CI fails if <85% test coverage).
5.4 Limitations in Reviews
Review criteria could have been more structured (e.g., checklist-based).
Score: 18/20 – Strong CI pipeline and automation, but code reviews could be more structured.
